[{"assignees":[],"body":"## Summary\n\nData race in `TestConsoleRun_CancelsLongRunningCommand` between the cancellation goroutine accessing `cmd.Process` and `cmd.Start()`/`cmd.Wait()` modifying it.\n\n## Race Details\n\n**Goroutine 18** (cancellation handler) reads `cmd.Process`:\n- `console.go:1315` - accessing `cmd.Process` \n- `process_unix.go:37` - `killProcessGroupWithSIGKILL()`\n\n**Goroutine 7** (main) writes `cmd.Process`:\n- `exec.(*Cmd).Start()` - initializes `cmd.Process`\n- `exec.(*Cmd).Wait()` - modifies process state\n\n## Root Cause\n\nThe cancellation goroutine is spawned at `console.go:1269` before `cmd.Start()` completes. When context cancellation fires, it tries to kill a process that may not be fully initialized.\n\n## Affected Code\n\n```\nfo/console.go:1269  - spawns cancellation goroutine\nfo/console.go:1315  - reads cmd.Process\nfo/process_unix.go:37 - killProcessGroupWithSIGKILL\n```\n\n## Reproduction\n\n```bash\ngo test -race ./fo/... -run \"CancelsLongRunning\"\n```\n\n## Suggested Fix\n\nEnsure `cmd.Process` is only accessed after `cmd.Start()` has completed. Options:\n1. Use a mutex to guard `cmd.Process` access\n2. Use a channel to signal when process is started\n3. Check `cmd.Process != nil` with proper synchronization before killing","closedAt":null,"createdAt":"2025-12-23T12:04:30Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdBQ","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":205,"state":"OPEN","title":"Race condition in process cancellation (cmd.Process access)","updatedAt":"2025-12-23T12:04:30Z"},{"assignees":[],"body":"## Problem\n\nFo currently has 14 formatters, each with bespoke parsing logic for different tool outputs. As we add more tools and want cross-tool features (hotspot aggregation, unified dashboards), we need a principled approach to input handling.\n\n### Why SARIF Is Not The Answer\n\nInitial intuition was to standardize on SARIF, but this fails for three reasons:\n\n1. **Not universal** — SARIF only covers static analysis diagnostics. Test events, metrics, and inventories dont fit.\n2. **Not streamable** — SARIF is a complete JSON document. Cannot emit partial results during long-running analysis.\n3. **File:line assumption** — Every SARIF result requires physical location. Where does \"entropy: 2.3\" go? Where does \"9 clones found\" go?\n\nSARIF is an interchange format for shipping analysis results between tools. Fo is a *presentation layer* — different job.\n\n## Analysis: Four Semantic Domains\n\nExamining all 14 formatters, tool outputs fall into four distinct semantic categories:\n\n### Domain 1: Diagnostic Stream\nFile:line issues from static analysis.\n- **Tools**: golangci-lint, nilaway, go vet, go-arch-lint, SARIF tools\n- **Core shape**: `{file, line, severity, rule, message, score?}`\n- **Streamable**: Yes (emit as discovered)\n\n### Domain 2: Test Event Stream  \nPackage/test progression with timing.\n- **Tools**: gotest, race detector\n- **Core shape**: `{package, test, action, output, elapsed}`\n- **Streamable**: Yes (go test -json is the model)\n\n### Domain 3: Metric Snapshot\nNamed values with optional trends/grouping.\n- **Tools**: nugstats, filesize, telemetry-signals\n- **Core shape**: `{name, value, previous?, unit?, group?, tier?}`\n- **Streamable**: Partial (groups can stream, summary at end)\n- **NOT file:line oriented**\n\n### Domain 4: Inventory\nLists of items with properties.\n- **Tools**: govulncheck (vulns), jscpd (clones), gofmt (files needing format)\n- **Core shape**: `{kind, items[], total}`\n- **Streamable**: Yes (emit items as found)\n\n## Proposed Architecture\n\n```\nTool Output → [Adapter] → Domain Type → [Renderer] → Visual Output\n                              ↓\n                        [Aggregator] (optional)\n                              ↓\n                      Cross-tool views (hotspots, summaries)\n```\n\n### Domain Type Definitions\n\n```go\n// Domain 1: Diagnostics\ntype Diagnostic struct {\n    Tool     string   `json:\"tool\"`\n    File     string   `json:\"file\"`\n    Line     int      `json:\"line,omitempty\"`\n    Severity string   `json:\"severity\"` // error|warning|info\n    Rule     string   `json:\"rule\"`\n    Message  string   `json:\"message\"`\n    Score    *float64 `json:\"score,omitempty\"` // complexity, etc.\n}\n\n// Domain 2: Test events — use go test -json as canonical\n\n// Domain 3: Metrics\ntype Metric struct {\n    Tool     string   `json:\"tool\"`\n    Name     string   `json:\"name\"`\n    Value    float64  `json:\"value\"`\n    Previous *float64 `json:\"previous,omitempty\"`\n    Unit     string   `json:\"unit,omitempty\"`\n    Group    string   `json:\"group,omitempty\"`\n    Tier     string   `json:\"tier,omitempty\"` // green|yellow|red\n}\n\n// Domain 4: Inventory\ntype InventoryItem struct {\n    Tool     string         `json:\"tool\"`\n    Kind     string         `json:\"kind\"` // vulnerability, clone, file\n    ID       string         `json:\"id,omitempty\"`\n    Label    string         `json:\"label\"`\n    File     string         `json:\"file,omitempty\"`\n    Severity string         `json:\"severity,omitempty\"`\n    Props    map[string]any `json:\"props,omitempty\"`\n}\n```\n\n### Wire Format: NDJSON with Domain Tag\n\n```jsonl\n{\"domain\":\"diagnostic\",\"tool\":\"golangci-lint\",\"file\":\"foo.go\",\"line\":42,\"severity\":\"warning\",\"rule\":\"gocyclo\",\"message\":\"complexity 25\",\"score\":25}\n{\"domain\":\"metric\",\"tool\":\"nugstats\",\"name\":\"trap\",\"value\":12,\"group\":\"kind\"}\n{\"domain\":\"inventory\",\"tool\":\"govulncheck\",\"kind\":\"vulnerability\",\"id\":\"GO-2024-1234\",\"label\":\"sql injection\"}\n{\"type\":\"end\",\"tool\":\"golangci-lint\",\"total\":15}\n```\n\n- Each line self-describes via `domain` field\n- `{\"type\":\"end\"}` signals stream completion with optional summary\n- Single JSON object (no array wrapper) for snapshots is valid subset\n\n## What This Enables\n\n1. **Reusable renderers** — `RankedListRenderer` works for any `Diagnostic` with scores\n2. **Cross-tool aggregation** — Collect all diagnostics, group by file, find hotspots across tools\n3. **Streaming for free** — NDJSON + domain types = live dashboard updates\n4. **Gradual adoption** — Existing formatters keep working, migrate incrementally\n5. **Tool independence** — Adapters handle tool quirks, renderers see clean domain types\n\n## Implementation Strategy\n\n### For Tools We Control\nAdd `-format=fo` flag that emits NDJSON in domain format:\n- nugstats, mcp-errors, filesize, telemetry-signals, orca-hygiene\n\n### For External Tools  \nWrite adapters that transform native output → domain types:\n- golangci-lint (SARIF → Diagnostic stream)\n- govulncheck (NDJSON → Inventory stream)\n- go test (pass-through, already NDJSON)\n\n### Incremental Path\n\n1. Define domain types in `pkg/dashboard/domain/`\n2. Refactor gotest formatter to: parse → domain → render (cleanest starting point)\n3. Add `-format=fo` to nugstats (simplest orca tool)\n4. Prove pattern works, then migrate others\n5. Build aggregator for cross-tool hotspots\n\n## Relationship to Other Work\n\n- **#203 (output consolidation)**: Complementary. #203 extracts shared *rendering* code. This issue defines shared *input* contracts. Can proceed in parallel.\n- **n:map:formatter-patterns**: Documents current output patterns. This issue addresses input patterns.\n\n## Open Questions\n\n- [ ] Should domain envelope include timestamp for streaming correlation?\n- [ ] How to handle multi-file diagnostics (e.g., \"duplicate of X in file Y\")?\n- [ ] Stream backpressure / buffering strategy for slow renderers?\n- [ ] Should adapters live in fo or in the source tools?\n\n## References\n\n- Pattern analysis: `n:map:formatter-patterns`\n- Current formatters: `pkg/dashboard/formatter_*.go`\n- Go test JSON spec: https://pkg.go.dev/cmd/test2json\n","closedAt":null,"createdAt":"2025-12-22T18:36:52Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"},{"id":"LA_kwDOOpIJEM8AAAACTISsHg","name":"architecture","description":"Architectural decisions and patterns","color":"7057ff"}],"number":204,"state":"OPEN","title":"Define domain-specific input contracts for fo consumption","updatedAt":"2025-12-22T18:36:52Z"},{"assignees":[],"body":"## Summary\nPlan and submit a PR to [uber-go/nilaway](https://github.com/uber-go/nilaway) adding native SARIF output support for GitHub Security tab integration.\n\n**Upstream issue exists:** [uber-go/nilaway#290](https://github.com/uber-go/nilaway/issues/290)\n\n## Why\n- SARIF is industry standard for static analysis results\n- Enables GitHub Code Scanning integration\n- NilAway already has `-json` flag, so pattern exists\n- `golang.org/x/tools/go/analysis` has SARIF helpers\n\n## Implementation Plan\n\n### 1. Research (1hr)\n- [ ] Review NilAway codebase structure\n- [ ] Check existing `-json` implementation for patterns\n- [ ] Review `golang.org/x/tools/go/analysis/sarif` package\n- [ ] Comment on upstream issue #290 to claim work\n\n### 2. Implementation (2-3hrs)\n- [ ] Add `-sarif` or `-output-format sarif` flag\n- [ ] Map NilAway diagnostics to SARIF format:\n  - `ruleId`: \"nilaway\" or specific rule IDs\n  - `level`: \"error\" (all nilaway findings are potential panics)\n  - `message.text`: existing message\n  - `locations[].physicalLocation`: from `posn` field\n- [ ] Add tests\n\n### 3. PR Process\n- [ ] Fork uber-go/nilaway\n- [ ] Create branch with implementation\n- [ ] Run their test suite\n- [ ] Submit PR referencing issue #290\n- [ ] Sign Uber CLA\n\n## SARIF Structure Reference\n```json\n{\n  \"$schema\": \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/main/sarif-2.1/schema/sarif-schema-2.1.0.json\",\n  \"version\": \"2.1.0\",\n  \"runs\": [{\n    \"tool\": {\"driver\": {\"name\": \"nilaway\", \"version\": \"X.Y.Z\"}},\n    \"results\": [{\n      \"ruleId\": \"nilaway\",\n      \"level\": \"error\",\n      \"message\": {\"text\": \"Potential nil panic...\"},\n      \"locations\": [{\n        \"physicalLocation\": {\n          \"artifactLocation\": {\"uri\": \"path/to/file.go\"},\n          \"region\": {\"startLine\": 123, \"startColumn\": 45}\n        }\n      }]\n    }]\n  }]\n}\n```\n\n## Priority\nLow - nice to have, not blocking. Can contribute when time permits.\n\n---\n*Moved from dkoosis/orca#1397*","closedAt":null,"createdAt":"2025-12-20T03:18:29Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"number":199,"state":"OPEN","title":"contrib: Add SARIF output support to NilAway (upstream PR)","updatedAt":"2025-12-20T03:18:29Z"},{"assignees":[],"body":"## Parent Epic\n#192 Formatter Architecture Consolidation\n\n## Summary\nAdd support for gitleaks secret detection output in the fo dashboard.\n\n## gitleaks JSON Output Format\n\nFrom gitleaks source (`report/finding.go`):\n```json\n[\n  {\n    \"RuleID\": \"aws-access-key-id\",\n    \"Description\": \"AWS Access Key\",\n    \"StartLine\": 42,\n    \"EndLine\": 42,\n    \"StartColumn\": 10,\n    \"EndColumn\": 30,\n    \"Match\": \"AKIAIOSFODNN7EXAMPLE\",\n    \"Secret\": \"AKIAIOSFODNN7EXAMPLE\",\n    \"File\": \"config/secrets.go\",\n    \"Commit\": \"a1b2c3d4\",\n    \"Author\": \"dev@example.com\",\n    \"Email\": \"dev@example.com\",\n    \"Date\": \"2024-01-15\",\n    \"Message\": \"Add configuration\",\n    \"Tags\": [\"key\", \"aws\"],\n    \"Fingerprint\": \"config/secrets.go:aws-access-key-id:42\"\n  }\n]\n```\n\n## Implementation\n\n### Files to Create\n\n**1. `pkg/dashboard/formatter_gitleaks.go`**\n\n```go\npackage dashboard\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"strings\"\n    \n    \"github.com/charmbracelet/lipgloss\"\n)\n\ntype GitleaksFormatter struct{}\n\nfunc (f *GitleaksFormatter) Matches(command string) bool {\n    return strings.Contains(command, \"gitleaks\")\n}\n\ntype gitleaksFinding struct {\n    RuleID      string   `json:\"RuleID\"`\n    Description string   `json:\"Description\"`\n    StartLine   int      `json:\"StartLine\"`\n    File        string   `json:\"File\"`\n    Secret      string   `json:\"Secret\"`\n    Commit      string   `json:\"Commit\"`\n    Author      string   `json:\"Author\"`\n    Tags        []string `json:\"Tags\"`\n}\n\nfunc (f *GitleaksFormatter) Format(lines []string, width int) string {\n    var b strings.Builder\n    \n    // Styles\n    errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#FF5F56\")).Bold(true)\n    successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#04B575\")).Bold(true)\n    headerStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#0077B6\")).Bold(true)\n    fileStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#CCCCCC\"))\n    mutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#626262\"))\n    ruleStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#FFBD2E\"))\n    \n    // Parse JSON\n    combined := strings.Join(lines, \"\\n\")\n    var findings []gitleaksFinding\n    \n    if err := json.Unmarshal([]byte(combined), &findings); err != nil {\n        // Check for \"no leaks found\" message\n        if strings.Contains(combined, \"no leaks found\") {\n            b.WriteString(successStyle.Render(\"✓ No secrets detected\\n\"))\n            return b.String()\n        }\n        return (&PlainFormatter{}).Format(lines, width)\n    }\n    \n    if len(findings) == 0 {\n        b.WriteString(successStyle.Render(\"✓ No secrets detected\\n\"))\n        return b.String()\n    }\n    \n    // Header\n    b.WriteString(errorStyle.Render(fmt.Sprintf(\"✗ %d secret(s) detected:\", len(findings))))\n    b.WriteString(\"\\n\\n\")\n    \n    // Group by file\n    byFile := make(map[string][]gitleaksFinding)\n    fileOrder := []string{}\n    for _, f := range findings {\n        if _, exists := byFile[f.File]; !exists {\n            fileOrder = append(fileOrder, f.File)\n        }\n        byFile[f.File] = append(byFile[f.File], f)\n    }\n    \n    displayed := 0\n    maxDisplay := 10\n    \n    for _, file := range fileOrder {\n        if displayed >= maxDisplay {\n            remaining := len(findings) - displayed\n            b.WriteString(mutedStyle.Render(fmt.Sprintf(\"\\n  ... and %d more secrets\\n\", remaining)))\n            break\n        }\n        \n        b.WriteString(headerStyle.Render(file))\n        b.WriteString(\"\\n\")\n        \n        for _, finding := range byFile[file] {\n            if displayed >= maxDisplay {\n                break\n            }\n            \n            // Redact secret: show first 4 + ... + last 4\n            redacted := redactSecret(finding.Secret)\n            \n            b.WriteString(fmt.Sprintf(\"  %s %s %s\\n\",\n                mutedStyle.Render(fmt.Sprintf(\":%d\", finding.StartLine)),\n                ruleStyle.Render(finding.RuleID),\n                fileStyle.Render(redacted)))\n            displayed++\n        }\n        b.WriteString(\"\\n\")\n    }\n    \n    return b.String()\n}\n\n// redactSecret shows first 4 and last 4 characters, hiding the middle\nfunc redactSecret(s string) string {\n    if len(s) <= 12 {\n        return strings.Repeat(\"*\", len(s))\n    }\n    return s[:4] + strings.Repeat(\"*\", len(s)-8) + s[len(s)-4:]\n}\n```\n\n### Registration\nAdd to `pkg/dashboard/formatter_registry.go`:\n```go\n&GitleaksFormatter{},\n```\n\n### Example Dashboard Output\n```\n◉ Security/gitleaks                           2 secret(s) detected\n\nconfig/secrets.go\n  :42  aws-access-key-id  AKIA************MPLE\n  :67  generic-api-key    sk_t************_xyz\n\ninternal/auth/tokens.go\n  :15  github-pat         ghp_************aBcD\n```\n\n## Security Note\n**CRITICAL**: Never display full secrets in output. Always redact to show only first 4 + last 4 characters.\n\n## Testing\n\n`pkg/dashboard/formatter_gitleaks_test.go`:\n```go\nfunc TestGitleaksFormatter_Format(t *testing.T) {\n    input := `[{\"RuleID\":\"aws-access-key-id\",\"Description\":\"AWS\",\"StartLine\":42,\"File\":\"config.go\",\"Secret\":\"AKIAIOSFODNN7EXAMPLE\"}]`\n    \n    f := &GitleaksFormatter{}\n    output := f.Format([]string{input}, 80)\n    \n    assert.Contains(t, output, \"secret(s) detected\")\n    assert.Contains(t, output, \"config.go\")\n    assert.Contains(t, output, \"aws-access-key-id\")\n    // Verify secret is redacted\n    assert.NotContains(t, output, \"AKIAIOSFODNN7EXAMPLE\")\n    assert.Contains(t, output, \"AKIA\")\n    assert.Contains(t, output, \"MPLE\")\n}\n\nfunc TestRedactSecret(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"short\", \"*****\"},\n        {\"AKIAIOSFODNN7EXAMPLE\", \"AKIA************MPLE\"},\n    }\n    for _, tc := range tests {\n        assert.Equal(t, tc.expected, redactSecret(tc.input))\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] `pkg/dashboard/formatter_gitleaks.go` created\n- [ ] JSON parsing handles gitleaks output array\n- [ ] Secrets properly redacted (first 4 + last 4 only)\n- [ ] Findings grouped by file\n- [ ] Truncation with \"... and N more\" for large outputs\n- [ ] \"No secrets detected\" for empty/clean output\n- [ ] Registered in formatter_registry.go\n- [ ] Unit tests pass\n- [ ] `go build ./...` succeeds","closedAt":null,"createdAt":"2025-12-16T17:56:25Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"number":197,"state":"OPEN","title":"Add gitleaks (secret detection) adapter and formatter","updatedAt":"2025-12-23T02:11:00Z"},{"assignees":[],"body":"## Parent Epic\n#192 Formatter Architecture Consolidation\n\n## Summary\nDashboard formatters should delegate parsing to existing pkg adapters rather than reimplementing parsing logic.\n\n## Problem\n`NilawayFormatter` in dashboard duplicates parsing from `pkg/nilaway.Adapter`:\n\n```go\n// pkg/dashboard/formatter.go - DUPLICATED\ntype nilawayFinding struct {\n    Posn    string `json:\"posn\"`\n    Message string `json:\"message\"`\n    Reason  string `json:\"reason\"`\n}\n\nfunc (f *NilawayFormatter) Format(lines []string, _ int) string {\n    var nested map[string]nilawayAnalyzerResult\n    json.Unmarshal([]byte(combined), &nested)  // reimplements parsing\n    // ...\n}\n```\n\n```go\n// pkg/nilaway/adapter.go - CANONICAL\ntype Finding struct {\n    Posn    string `json:\"posn\"`\n    Message string `json:\"message\"`\n    Reason  string `json:\"reason\"`\n    File    string `json:\"-\"`  // parsed\n    Line    int    `json:\"-\"`  // parsed\n    Column  int    `json:\"-\"`  // parsed\n}\n\nfunc (a *Adapter) Parse(r io.Reader) (*Result, error) { ... }\n```\n\n## Solution\n\nDashboard formatters become thin wrappers:\n\n```go\n// pkg/dashboard/formatters/nilaway.go\ntype NilawayDashboardFormatter struct {\n    adapter *nilaway.Adapter\n    theme   *design.Config\n}\n\nfunc NewNilawayDashboardFormatter(adapter *nilaway.Adapter, theme *design.Config) *NilawayDashboardFormatter {\n    return &NilawayDashboardFormatter{adapter: adapter, theme: theme}\n}\n\nfunc (f *NilawayDashboardFormatter) Format(lines []string, width int) string {\n    // Delegate parsing to adapter\n    result, err := f.adapter.Parse(strings.NewReader(strings.Join(lines, \"\\n\")))\n    if err != nil {\n        return f.renderError(err, width)\n    }\n    \n    // Render the parsed result (dashboard-specific formatting)\n    return f.renderResult(result, width)\n}\n\nfunc (f *NilawayDashboardFormatter) renderResult(result *nilaway.Result, width int) string {\n    // Use theme colors, format for dashboard panel\n    // This is the ONLY code specific to dashboard display\n}\n```\n\n## Formatters to Migrate\n\n| Dashboard Formatter | Pkg Adapter | Status |\n|---------------------|-------------|--------|\n| NilawayFormatter | pkg/nilaway | Needs migration |\n| RaceFormatter | pkg/racedetect | Needs migration |\n| GofmtFormatter | pkg/gofmt | Needs migration |\n| GoArchLintFormatter | pkg/archlint | Needs migration |\n| (new) GoleakFormatter | pkg/goleak | Create new |\n| (new) FuzzFormatter | pkg/fuzz | Create new |\n\n## Acceptance Criteria\n- [ ] `NilawayFormatter` delegates to `nilaway.Adapter`\n- [ ] `RaceFormatter` delegates to `racedetect.Adapter`\n- [ ] `GofmtFormatter` delegates to `gofmt.Adapter`\n- [ ] `GoArchLintFormatter` delegates to `archlint.Adapter`\n- [ ] New `GoleakFormatter` using `goleak.Adapter`\n- [ ] New `FuzzFormatter` using `fuzz.Adapter`\n- [ ] No duplicate type definitions in formatters\n- [ ] All tests pass\n\n## Dependencies\n- #193 (extract formatter.go) - recommended first\n- #195 (theme injection) - can be done together\n","closedAt":null,"createdAt":"2025-12-16T17:55:37Z","labels":[],"number":196,"state":"OPEN","title":"Delegate dashboard formatters to pkg adapters (eliminate duplication)","updatedAt":"2025-12-20T03:49:35Z"},{"assignees":[],"body":"## Parent Epic\n#192 Formatter Architecture Consolidation\n\n## Summary\nDashboard formatters currently hardcode lipgloss styles. They should use the theme system like pkg adapters do.\n\n## Problem\n```go\n// Current: hardcoded styles in NilawayFormatter\nfunc (f *NilawayFormatter) Format(lines []string, _ int) string {\n    errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#FF5F56\")).Bold(true)\n    successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#04B575\")).Bold(true)\n    // ... more hardcoded colors\n}\n```\n\nMeanwhile pkg adapters properly use themes:\n```go\n// pkg/nilaway/adapter.go\ntype Adapter struct {\n    theme *design.Config\n}\n```\n\n## Solution\n\n### 1. Formatter Constructor with Theme\n```go\ntype NilawayDashboardFormatter struct {\n    theme *design.Config\n}\n\nfunc NewNilawayDashboardFormatter(theme *design.Config) *NilawayDashboardFormatter {\n    return &NilawayDashboardFormatter{theme: theme}\n}\n```\n\n### 2. Registry Construction\n```go\nfunc NewFormatterRegistry(theme *design.Config) *FormatterRegistry {\n    return &FormatterRegistry{\n        theme: theme,\n        formatters: []OutputFormatter{\n            NewRaceDashboardFormatter(racedetect.NewAdapter(theme)),\n            NewGoTestFormatter(theme),\n            NewNilawayDashboardFormatter(nilaway.NewAdapter(theme)),\n            NewGoleakDashboardFormatter(goleak.NewAdapter(theme)),\n            // ...\n            NewPlainFormatter(),  // no theme needed\n        },\n    }\n}\n```\n\n### 3. Theme Usage in Format()\n```go\nfunc (f *NilawayDashboardFormatter) Format(lines []string, width int) string {\n    // Use theme colors\n    errorStyle := lipgloss.NewStyle().\n        Foreground(lipgloss.Color(f.theme.Colors.Error))\n    successStyle := lipgloss.NewStyle().\n        Foreground(lipgloss.Color(f.theme.Colors.Success))\n    // ...\n}\n```\n\n### 4. Update TUI to Pass Theme\n```go\n// pkg/dashboard/tui.go\nfunc NewModel(tasks []Task, theme *design.Config) Model {\n    return Model{\n        // ...\n        formatters: NewFormatterRegistry(theme),\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] All formatters accept theme in constructor\n- [ ] `FormatterRegistry` constructed with theme\n- [ ] No hardcoded color values in formatters\n- [ ] Dashboard respects `.fo.yaml` theme configuration\n- [ ] Visual output unchanged with default theme\n","closedAt":null,"createdAt":"2025-12-16T17:55:14Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"number":195,"state":"OPEN","title":"Add theme injection for dashboard formatters","updatedAt":"2025-12-20T03:49:36Z"},{"assignees":[],"body":"## Parent Epic\n#192 Formatter Architecture Consolidation\n\n## Summary\nReplace brittle command-string matching with content sniffing for more robust format detection.\n\n## Problem\nCurrent `Matches(command string)` relies on substring checks:\n```go\nfunc (f *NilawayFormatter) Matches(command string) bool {\n    return strings.Contains(command, \"nilaway\")  // breaks with aliases/wrappers\n}\n```\n\n## Solution\nExtend the `OutputFormatter` interface:\n\n```go\ntype OutputFormatter interface {\n    Format(lines []string, width int) string\n    MatchesCommand(command string) bool  // hint (cheap, checked first)\n    MatchesContent(lines []string) bool  // definitive (checked if command ambiguous)\n    Priority() int                        // for ordering when multiple match\n}\n```\n\n## Content Detection Examples\n\n**nilaway** - Look for nested JSON structure:\n```go\nfunc (f *NilawayFormatter) MatchesContent(lines []string) bool {\n    combined := strings.Join(lines, \"\")\n    return strings.Contains(combined, `\"nilaway\":[`)\n}\n```\n\n**go test -json** - Look for test event JSON:\n```go\nfunc (f *GoTestFormatter) MatchesContent(lines []string) bool {\n    for _, line := range lines[:min(10, len(lines))] {\n        if strings.Contains(line, `\"Action\":\"`) && strings.Contains(line, `\"Package\":\"`) {\n            return true\n        }\n    }\n    return false\n}\n```\n\n**SARIF** - Look for SARIF schema marker:\n```go\nfunc (f *SARIFFormatter) MatchesContent(lines []string) bool {\n    combined := strings.Join(lines, \"\")\n    return strings.Contains(combined, `\"$schema\"`) && strings.Contains(combined, \"sarif\")\n}\n```\n\n## Registry Logic\n```go\nfunc (r *Registry) SelectFormatter(command string, lines []string) OutputFormatter {\n    // 1. Try command match first (cheap)\n    var candidates []OutputFormatter\n    for _, f := range r.formatters {\n        if f.MatchesCommand(command) {\n            candidates = append(candidates, f)\n        }\n    }\n    \n    // 2. If single match, use it\n    if len(candidates) == 1 {\n        return candidates[0]\n    }\n    \n    // 3. If ambiguous or no match, try content detection\n    for _, f := range r.formatters {\n        if f.MatchesContent(lines) {\n            return f\n        }\n    }\n    \n    return r.plainFormatter  // fallback\n}\n```\n\n## Acceptance Criteria\n- [ ] `OutputFormatter` interface extended with `MatchesContent` and `Priority`\n- [ ] All existing formatters implement content detection\n- [ ] Registry uses two-phase detection\n- [ ] Tests verify content detection works without command hints\n","closedAt":null,"createdAt":"2025-12-16T17:54:50Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"number":194,"state":"OPEN","title":"Implement content-based format detection for formatters","updatedAt":"2025-12-20T03:49:37Z"},{"assignees":[],"body":"## Summary\n\nDashboard formatters (`pkg/dashboard/formatter.go`) have grown to ~2000 lines and duplicate parsing logic that already exists in `pkg/*/adapter.go`. This creates maintenance burden and prevents theme consistency.\n\n## Problem\n\n1. **formatter.go is a god file** - 1958 lines, 11 formatters, each with parsing + rendering + hardcoded styles\n2. **Duplication** - `NilawayFormatter` reimplements `nilaway.Adapter.Parse`; same for race detection\n3. **No shared types** - Each formatter defines internal types that duplicate exported adapter types\n4. **Brittle matching** - `Matches(command string)` uses substring checks\n5. **No theme support** - Formatters hardcode lipgloss styles\n\n## Solution\n\nMake dashboard formatters **thin wrappers** that delegate to pkg adapters:\n\n```\nDashboard TUI\n  └── FormatterRegistry\n        ├── NilawayDashboardFormatter → nilaway.Adapter.Parse() → theme.Render()\n        ├── GoleakDashboardFormatter  → goleak.Adapter.Parse()  → theme.Render()\n        └── ...\n```\n\n## Tasks\n\n- [ ] #193 Extract formatter.go into separate files\n- [ ] #194 Implement content-based format detection\n- [ ] #195 Add theme injection for dashboard formatters\n- [ ] #196 Delegate dashboard formatters to pkg adapters\n- [ ] #197 Add gitleaks adapter + formatter\n- [ ] #191 Add jscpd adapter (existing issue)\n\n## Benefits\n\n- Single source of truth for parsing\n- Theme consistency across pipe and dashboard modes\n- Adding new tools = adapter + thin formatter\n- Each formatter testable in isolation\n\n## References\n\n- KG: `n:trap:fo-formatter-duplication`\n- KG: `n:map:fo-formatter-consolidation`\n- KG: `n:map:fo-new-adapters`\n","closedAt":null,"createdAt":"2025-12-16T17:54:08Z","labels":[],"number":192,"state":"OPEN","title":"Epic: Formatter Architecture Consolidation","updatedAt":"2025-12-20T03:49:37Z"},{"assignees":[],"body":"## Summary\nAdd a formatter to parse and render `fieldalignment` output in the fo dashboard.\n\n## Background\n`fieldalignment` is a Go analyzer that checks struct field ordering for optimal memory alignment. It is part of `golang.org/x/tools/go/analysis/passes/fieldalignment`.\n\n## Output Format\n\nPlain text, one finding per line:\n```\n/path/to/file.go:25:10: struct with 64 pointer bytes could be 48\n/path/to/file.go:89:6: struct of size 72 could be 56\n```\n\n**Pattern:** `<file>:<line>:<col>: struct (with|of size) <current> (pointer bytes|) could be <optimal>`\n\n## Implementation\n\n### File to Create\n`pkg/dashboard/formatter_fieldalignment.go`\n\n### Struct Definitions\n```go\ntype FieldalignmentFormatter struct{}\n\ntype fieldalignmentFinding struct {\n    File    string\n    Line    int\n    Col     int\n    Current int  // current size/pointer bytes\n    Optimal int  // optimized size\n    Message string\n}\n```\n\n### Matches Function\n```go\nfunc (f *FieldalignmentFormatter) Matches(command string) bool {\n    return strings.Contains(command, \"fieldalignment\")\n}\n```\n\n### Parsing Logic\nUse regex to extract components:\n```go\nvar fieldalignmentRegex = regexp.MustCompile(`^(.+):(\\d+):(\\d+):\\s+struct\\s+(?:with\\s+(\\d+)\\s+pointer bytes|of size\\s+(\\d+))\\s+could be\\s+(\\d+)`)\n```\n\n### Format Function Structure\n1. Parse each line using regex\n2. Group findings by file\n3. Calculate savings per file and total\n4. Render with file headers and indented findings\n\n### Example Dashboard Rendering\n```\n◉ Field Alignment                    3 structs to optimize\n\npkg/design/box.go\n   :18  64 → 48 bytes  (-16)\n   :25  72 → 56 bytes  (-16)\n\npkg/design/config.go\n  :146  256 → 248 bytes  (-8)\n\n  Total: 40 bytes potential savings\n```\n\n### Styles (copy from existing formatters)\n```go\nheaderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#0077B6\")).Bold(true)\nwarnStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#FFBD2E\")).Bold(true)\nsuccessStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#04B575\")).Bold(true)\nfileStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#CCCCCC\"))\nmutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#626262\"))\n```\n\n## Reference Implementation\nUse `pkg/dashboard/formatter_nilaway.go` as template - same pattern of:\n1. Parse output\n2. Group by file\n3. Display with truncation (\"... and N more\")\n\n## Registration\nAdd to `pkg/dashboard/formatter_registry.go`:\n```go\n&FieldalignmentFormatter{},\n```\n\n## Testing\nCreate `pkg/dashboard/formatter_fieldalignment_test.go`:\n```go\nfunc TestFieldalignmentFormatter_Format(t *testing.T) {\n    lines := []string{\n        \"/path/to/file.go:25:10: struct with 64 pointer bytes could be 48\",\n        \"/path/to/file.go:89:6: struct of size 72 could be 56\",\n    }\n    f := &FieldalignmentFormatter{}\n    output := f.Format(lines, 80)\n    \n    assert.Contains(t, output, \"structs to optimize\")\n    assert.Contains(t, output, \"file.go\")\n    assert.Contains(t, output, \"64\")\n    assert.Contains(t, output, \"48\")\n}\n```\n\n## Acceptance Criteria\n- [ ] `pkg/dashboard/formatter_fieldalignment.go` created\n- [ ] Regex correctly parses both \"pointer bytes\" and \"of size\" variants\n- [ ] Findings grouped by file\n- [ ] Savings calculated and displayed\n- [ ] Truncation with \"... and N more\" for large outputs\n- [ ] Registered in formatter_registry.go\n- [ ] Unit tests pass\n- [ ] `go build ./...` succeeds","closedAt":null,"createdAt":"2025-12-16T17:23:38Z","labels":[],"number":190,"state":"OPEN","title":"Add fieldalignment formatter for dashboard","updatedAt":"2025-12-23T02:09:00Z"},{"assignees":[],"body":"# Feature Request: Markdown Output Target\n\n## Problem Description\n\n`fo` currently renders patterns to console (ANSI colors, Unicode blocks, terminal width). To integrate with documentation workflows—specifically, exporting pattern output to Obsidian wikis alongside knowledge graph exports—`fo` needs a Markdown output target.\n\n## Use Case\n\n**Orca integration**: The Orca knowledge graph exports nuggets as Markdown files to an Obsidian vault. These nuggets include build telemetry, test results, and quality metrics. Having `fo` output to the same wiki space would create a unified dashboard—patterns like Sparkline (build time trends), Leaderboard (slowest tests), and TestTable (test results) rendered as native Obsidian markdown.\n\n**Documentation generation**: Build reports, test summaries, and quality dashboards could be committed to repos or published to wikis.\n\n**CI artifacts**: Markdown output could be attached to PRs as build summaries.\n\n## Proposed Solution\n\n### RenderTarget abstraction\n\nIntroduce a `RenderTarget` interface that separates *what* to render from *how*:\n\n```go\ntype RenderTarget interface {\n    Heading(level int, text string) string\n    List(items []string) string\n    CodeBlock(lang, code string) string\n    Callout(style, title, body string) string  // style: warning, info, tip, danger\n    Table(headers []string, rows [][]string) string\n    Link(text, target string) string\n    Sparkline(values []float64, label, unit string) string\n    Bold(text string) string\n    Code(text string) string  // inline code\n}\n```\n\n### Implementations\n\n**ConsoleTarget** (current behavior):\n- Uses lipgloss for colors/styling\n- Unicode blocks for sparklines\n- Terminal width awareness\n\n**MarkdownTarget** (new):\n- Standard markdown syntax\n- Obsidian callout syntax: `> [!warning]`\n- Code blocks with language hints\n- Tables using pipe syntax\n- Sparklines as inline code or small code blocks\n\n### CLI interface\n\n```bash\n# Console output (default, current behavior)\nfo -- go test ./...\n\n# Markdown output to stdout\nfo --format md -- go test ./...\n\n# Markdown output to file\nfo --format md -o build-report.md -- go test ./...\n```\n\n## Files to Modify\n\n| File | Change |\n|------|--------|\n| `fo/target.go` | NEW - RenderTarget interface |\n| `fo/console_target.go` | Extract from current rendering |\n| `fo/markdown_target.go` | NEW - Markdown implementation |\n| `fo/pattern/*.go` | Update to use RenderTarget |\n| `cmd/main.go` | Add --format flag |\n\n## Migration Path\n\n1. Extract RenderTarget interface from current console rendering\n2. Implement MarkdownTarget\n3. Update patterns to use RenderTarget\n4. Add --format flag to CLI\n5. Document markdown output\n\n## Acceptance Criteria\n\n- [ ] RenderTarget interface defined with methods above\n- [ ] ConsoleTarget extracted (no behavior change)\n- [ ] MarkdownTarget implemented\n- [ ] `fo --format md -- go test ./...` produces valid markdown\n- [ ] Sparklines render in markdown (inline code with Unicode or ASCII fallback)\n- [ ] Tables render with pipe syntax\n- [ ] Callouts use Obsidian syntax when configured\n- [ ] `-o file.md` writes to file\n- [ ] All existing patterns work with both targets\n- [ ] Documentation updated\n- [ ] `go test ./...` passes\n\n## Alternatives Considered\n\n1. **Post-process console output**: Strip ANSI codes and convert. Lossy—sparklines become garbage, tables lose alignment.\n\n2. **Separate markdown patterns**: Duplicate pattern types for markdown. Violates DRY, maintenance burden.\n\n3. **Template-based rendering**: Each pattern has console and markdown templates. More flexible but adds template language complexity.\n\n## Related\n\n- Orca's `kg export-wiki` command (nuggets → Obsidian markdown)\n- Potential shared RenderTarget abstraction between fo and Orca","closedAt":null,"createdAt":"2025-12-13T18:50:17Z","labels":[],"number":176,"state":"OPEN","title":"Feature Request: Markdown Output Target","updatedAt":"2025-12-13T20:38:36Z"},{"assignees":[],"body":"## Vision\n\nThe McKinsey associate's value comes from recognizing what she's looking at. Each adapter is domain expertise - \"I know how to read this format and present it clearly.\"\n\nCurrent adapter coverage is limited. Expanding it increases fo's usefulness across more workflows.\n\n## Current Adapters\n\nNeed to audit `pkg/adapter/` to document current coverage.\n\n## Target Adapters (prioritized)\n\n**High value (common in Go/Mage workflows)**\n- [ ] Go test JSON (`go test -json`) - may exist, verify\n- [ ] Go build errors (compiler output)\n- [ ] golangci-lint output (multiple formats)\n- [ ] go vet output\n\n**Medium value (broader coverage)**  \n- [ ] Generic JSON (pretty print with syntax highlighting)\n- [ ] Generic compiler errors (file:line:col pattern)\n- [ ] Make/Mage task output (target names, timing)\n- [ ] Git status/diff summary\n\n**Lower priority (specialized)**\n- [ ] Docker build output\n- [ ] Terraform plan output\n- [ ] Test coverage reports\n\n## Adapter Contract\n\nEach adapter should:\n1. `Detect(lines []string) bool` - can I handle this?\n2. `Parse(io.Reader) (Pattern, error)` - extract structured data\n3. Return a `Pattern` that knows how to `Render(config)` itself\n\n## Files\n\n- `pkg/adapter/*.go`\n\n## Acceptance Criteria\n\n- [ ] Audit completed: document existing adapters in README\n- [ ] At least 5 working adapters covering common Go workflows\n- [ ] Each adapter has detection tests\n- [ ] README documents supported formats with examples\n- [ ] `go test ./pkg/adapter/...` passes\n\n## Related\n\n- Feeds into #159 (multi-stream composition) - more adapters = smarter composition","closedAt":null,"createdAt":"2025-11-29T22:04:54Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"number":160,"state":"OPEN","title":"Expand adapter vocabulary (domain expertise)","updatedAt":"2025-12-20T03:49:36Z"},{"assignees":[],"body":"## Vision\n\nThe McKinsey associate receives 27 messy output files and transforms them into a unified narrative. This is multi-stream composition - not just one pipe, but multiple sources synthesized into a coherent presentation.\n\n## Use Cases\n\n```bash\n# Combine multiple log files into unified view\nfo --compose build.log test.log lint.log\n\n# Process directory of outputs\nfo --dir ./ci-artifacts/\n\n# Named sections from different sources  \nfo --section \"Build\" build.log --section \"Test\" test.log\n```\n\n## Design Questions\n\n1. **Sequential vs parallel**: Process files one after another, or interleave by timestamp?\n2. **Section boundaries**: Each file becomes a section? Or merge related content?\n3. **Conflict resolution**: If two files have test results, merge or separate?\n\n## Implementation Sketch\n\n```go\ntype CompositionPlan struct {\n    Sources []Source\n    Mode    CompositionMode // Sequential, Interleaved, Merged\n}\n\ntype Source struct {\n    Name   string\n    Input  io.Reader\n    Hint   string // optional pattern hint\n}\n\nfunc (c *Console) RunComposition(plan CompositionPlan) error\n```\n\n## Files\n\n- `cmd/main.go` (CLI parsing for compose mode)\n- `fo/composition.go` (NEW - multi-source orchestration)\n\n## Acceptance Criteria\n\n- [ ] `fo --compose file1 file2` processes multiple files\n- [ ] Output shows clear provenance (which file each section came from)\n- [ ] Unified visual treatment across all sources\n- [ ] CLI help documents compose mode\n- [ ] Unit tests for composition logic\n- [ ] `go test ./...` passes\n\n## Depends On\n\n- #156 (Editor mode foundation)\n- #157 (Streaming processor)\n\n## Future\n\nThis is the foundation for the \"intelligent intern\" who can recognize relationships between outputs and synthesize them intelligently.","closedAt":null,"createdAt":"2025-11-29T22:04:38Z","labels":[],"number":159,"state":"OPEN","title":"Multi-stream composition (the 27 messy files)","updatedAt":"2025-12-20T03:49:37Z"}]
