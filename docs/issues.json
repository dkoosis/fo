[{"assignees":[],"body":"## Problem\n\nDocumentation and examples show individual patterns in isolation. Users need to understand how to compose multiple patterns together to create dashboard-like output for complex build processes.\n\n## Use Cases\n\n- Build pipeline: Summary (overall stats) + Workflow (pipeline stages) + TestTable (test results)\n- Quality report: Comparison (coverage delta) + Leaderboard (slowest tests) + Inventory (artifacts)\n- CI dashboard: Multiple CommandResults + Summary rollup\n\n## Proposal\n\nCreate `examples/composition/` demonstrating:\n\n**Example 1: Build Dashboard**\n```go\n// Show complete build process with multiple patterns\nconsole.RenderSummary(buildSummary)\nconsole.RenderWorkflow(pipelineStages)\nconsole.RenderTestTable(testResults)\nconsole.RenderInventory(artifacts)\n```\n\n**Example 2: Quality Dashboard**\n```go\n// Compare metrics over time with details\nconsole.RenderComparison(coverageChange)\nconsole.RenderLeaderboard(slowestTests)\nconsole.RenderSparkline(coverageTrend)\n```\n\n**Example 3: Makefile Integration**\nShow how to use mageconsole patterns in a real Makefile with multiple targets that compose together.\n\n## Files to Create\n\n- `examples/composition/dashboard.go` - Complete build dashboard\n- `examples/composition/quality.go` - Quality metrics dashboard\n- `examples/composition/Makefile` - Real-world Makefile example\n- `examples/composition/README.md` - Explanation and screenshots\n\n## Benefits\n\n- Demonstrates composability of pattern system\n- Provides templates for common use cases\n- Shows best practices for multi-pattern layouts\n- Helps users understand the \"thoughtful dashboard\" vision\n\n## Priority\n\nMedium - improves documentation and demonstrates library capabilities","createdAt":"2025-11-23T20:42:54Z","labels":[],"number":75,"state":"CLOSED","title":"Add multi-pattern composition examples","updatedAt":"2025-11-23T20:42:54Z","closedAt":"2025-01-23T00:00:00Z"},{"assignees":[],"body":"## Problem\n\nCurrent rendering uses one line per item, which works well for small datasets but wastes space for larger ones. Terminal real estate is limited, especially when combining multiple patterns.\n\n## Use Cases\n\n- CI logs with space constraints\n- Large test suites (hundreds of packages)\n- Multi-pattern dashboards (need to fit several patterns on screen)\n- Quick scans of build output\n\n## Proposal\n\nAdd density modes to theme configuration:\n\n```go\n// internal/design/theme.go\ntype DensityMode string\n\nconst (\n    DensityDetailed DensityMode = \"detailed\"  // Current: one item per line\n    DensityBalanced DensityMode = \"balanced\"  // 2 columns where appropriate\n    DensityCompact  DensityMode = \"compact\"   // 3 columns, minimal spacing\n)\n```\n\nExamples:\n\n**TestTable Compact Mode:**\n```\npkg/api ✓ 42 tests 2.1s    pkg/db ✓ 18 tests 0.8s    pkg/ui ✗ 31 tests 3.2s\n```\n\n**Inventory Compact Mode:**\n```\nmyapp [2.3MB]  myctl [1.1MB]  mylib [450KB]\n```\n\n## Implementation\n\n- Add DensityMode to GlobalThemeSettings\n- Modify renderers to support multi-column layouts\n- Keep detailed mode as default (backward compatible)\n- Auto-detect terminal width for intelligent column selection\n\n## Priority\n\nMedium - improves usability for real-world build logs","createdAt":"2025-11-23T20:42:38Z","labels":[],"number":74,"state":"CLOSED","title":"Add compact rendering modes for data density","updatedAt":"2025-11-23T20:42:38Z","closedAt":"2025-01-23T00:00:00Z"},{"assignees":[],"body":"## Problem\n\nTestTable shows all test results in the order they occur. A Leaderboard pattern would rank items by a specific metric and show only the top/bottom N. This helps identify optimization targets.\n\n## Use Cases\n\n- Slowest N tests (optimization targets)\n- Largest N binaries (size analysis)\n- Files with most linting warnings (quality hotspots)\n- Packages with lowest coverage (test gap identification)\n\n## Distinction from TestTable\n\nTestTable is comprehensive (shows everything). Leaderboard is selective (top/bottom N by criterion). Both have value in different contexts.\n\n## Implementation\n\n```go\n// internal/design/patterns.go\ntype LeaderboardItem struct {\n    Name    string\n    Metric  string  // e.g., \"2.3s\", \"45MB\", \"12 warnings\"\n    Value   float64 // Numeric value for ranking\n    Rank    int     // Position in ranking\n    Context string  // Additional info\n}\n\ntype Leaderboard struct {\n    Label      string\n    MetricName string  // \"Duration\", \"Size\", \"Warning Count\"\n    Items      []LeaderboardItem\n    Direction  string  // \"highest\" or \"lowest\"\n    TotalCount int     // Total items before filtering to top N\n}\n```\n\n## Priority\n\nMedium - useful for build optimization workflows, complements existing TestTable pattern","createdAt":"2025-11-23T20:42:23Z","labels":[],"number":73,"state":"CLOSED","title":"Implement Leaderboard pattern for ranked metrics","updatedAt":"2025-11-23T20:42:23Z","closedAt":"2025-01-23T00:00:00Z"},{"assignees":[],"body":"## Issue\n\nCurrent README positions fo as a \"command-line utility for standardizing command output\" - undersells the pattern-based design system architecture.\n\n## Proposal\n\nLead with:\n- Pattern-based presentation layer for build output\n- Separates semantic content from visual theme\n- Rich-ASCII components (tables, workflows, comparisons, summaries)\n- Cognitive load-aware rendering\n\nKeep practical examples but frame within the design system context.\n\n## Priority\n\nLow - documentation improvement, not functional gap","createdAt":"2025-11-23T20:39:22Z","labels":[],"number":72,"state":"CLOSED","title":"Update README to reflect design system focus","updatedAt":"2025-11-23T20:39:22Z","closedAt":"2025-01-23T00:00:00Z"},{"assignees":[],"body":"## Problem\n\nThe vision doc promises sparklines but they're not implemented. Sparklines are word-sized graphics using Unicode blocks (▂▃▅▆▇) to show trends inline with metrics.\n\n## Use Cases\n\n- Test duration trends over last N runs\n- Coverage percentage changes\n- Build size progression\n- Error count trends\n\n## Implementation\n\n```go\n// internal/design/patterns.go\ntype Sparkline struct {\n    Label  string\n    Values []float64\n    Min    float64  // Optional scale bounds\n    Max    float64\n    Unit   string   // e.g., \"ms\", \"%\"\n}\n```\n\nRenderer uses Unicode block elements: ▁▂▃▄▅▆▇█\n\n## Priority\n\nMedium - nice-to-have visualization enhancement","createdAt":"2025-11-23T20:39:13Z","labels":[],"number":71,"state":"CLOSED","title":"Implement Sparkline pattern for trend visualization","updatedAt":"2025-11-23T20:39:13Z","closedAt":"2025-01-23T00:00:00Z"},{"assignees":[],"body":"## Context\n\nfo currently captures command output as lines and classifies them (errors, warnings, etc.). However, many modern tools emit structured output that could be parsed into richer patterns.\n\n## Proposal\n\nAdd stream adapters that detect and parse structured formats:\n\n**Go Test JSON**\n```bash\nfo -- go test -json ./...\n# Auto-detect JSON output → parse into TestTable pattern\n```\n\n**Other Formats**\n- Jest/Vitest JSON reporters → TestTable\n- Go build output → Inventory (binaries produced)\n- golangci-lint JSON → structured error report\n\n## Design\n\n```go\ntype StreamAdapter interface {\n    Detect(firstLines []string) bool\n    Parse(output io.Reader) (Pattern, error)\n}\n\n// Register adapters\nRegisterAdapter(\\u0026GoTestJSONAdapter{})\nRegisterAdapter(\\u0026JestJSONAdapter{})\n```\n\n## Benefits\n\n- Richer visualization of test results\n- Automatic table/metric extraction\n- Preserves raw output as fallback\n\n## Note\n\nThis builds on the existing pattern architecture - not a replacement of it. The CommandResult pattern remains valid for unstructured output.","createdAt":"2025-11-23T20:38:02Z","labels":[],"number":70,"state":"CLOSED","title":"Stream adapters for structured command output","updatedAt":"2025-11-23T20:38:02Z","closedAt":"2025-01-23T00:00:00Z"},{"assignees":[],"body":"## Problem\n\nWith the pattern renderer implemented (#62), the fo CLI needs to be updated to use it. Currently fo CLI wraps commands with old imperative API. It should create CommandResult patterns and use the renderer.\n\n## Current CLI Flow\n\n```go\n// cmd/fo/main.go (current)\nfunc main() {\n    cfg := parseFlags()\n    console := mageconsole.NewConsole(cfg)\n    \n    result, err := console.Run(label, command, args...)\n    // Old imperative rendering\n}\n```\n\n## New CLI Flow\n\n```go\n// cmd/fo/main.go (new)\nfunc main() {\n    flags := parseFlags()\n    \n    // Load theme (from flag, env, or default)\n    theme := loadTheme(flags.Theme)\n    \n    // Execute command (separate from rendering)\n    result := executeCommand(flags.Label, flags.Command, flags.Args)\n    \n    // Render using pattern\n    renderer := patterns.NewRenderer(theme, os.Stdout)\n    renderer.Render(result)\n    \n    os.Exit(result.ExitCode)\n}\n\nfunc executeCommand(label string, cmd string, args []string) patterns.CommandResult {\n    start := time.Now()\n    \n    command := exec.Command(cmd, args...)\n    var output bytes.Buffer\n    command.Stdout = &output\n    command.Stderr = &output\n    \n    err := command.Run()\n    exitCode := 0\n    if err != nil {\n        if exitErr, ok := err.(*exec.ExitError); ok {\n            exitCode = exitErr.ExitCode()\n        } else {\n            exitCode = 1\n        }\n    }\n    \n    return patterns.CommandResult{\n        Label:    label,\n        Command:  append([]string{cmd}, args...),\n        ExitCode: exitCode,\n        Duration: time.Since(start),\n        Output:   output.Bytes(),\n        Error:    err,\n    }\n}\n```\n\n## CLI Flag Changes\n\nKeep existing flags but add theme support:\n\n```\nfo [flags] -- <COMMAND> [ARGS...]\n\nFlags:\n  -l, --label string       Task label (default: command name)\n  -s, --stream            Stream output (vs capture)\n  --theme string          Theme to use (default: \"orca\")\n  --theme-file string     Custom theme YAML file\n  --show-output string    When to show output (on-fail|always|never)\n  --no-color              Disable colors\n  --ci                    CI-friendly output\n  -h, --help              Show help\n```\n\n## Theme Resolution\n\n```go\nfunc loadTheme(themeName, themeFile string) patterns.Theme {\n    // Priority:\n    // 1. --theme-file (custom YAML)\n    // 2. --theme (built-in name)\n    // 3. FO_THEME env var\n    // 4. Default (\"orca\")\n    \n    if themeFile != \"\" {\n        return patterns.LoadTheme(themeFile)\n    }\n    \n    if themeName == \"\" {\n        themeName = os.Getenv(\"FO_THEME\")\n    }\n    if themeName == \"\" {\n        themeName = \"orca\"\n    }\n    \n    return patterns.BuiltinTheme(themeName)\n}\n```\n\n## Stream Mode Handling\n\nStream mode (-s flag) bypasses capture and renders in real-time:\n\n```go\nif flags.Stream {\n    // Don't use CommandResult pattern - stream directly\n    // This is a special case where pattern approach doesn't apply\n    // Just pass through with minimal formatting\n    streamCommand(flags.Label, cmd, args, renderer)\n} else {\n    // Normal capture mode uses CommandResult pattern\n    result := executeCommand(flags.Label, cmd, args)\n    renderer.Render(result)\n}\n```\n\n## Backward Compatibility\n\n**Breaking change**: This changes how fo CLI works internally. However, the command-line interface remains similar:\n\n**Before:**\n```bash\nfo -- go test ./...\nfo -l \"Build\" -- go build ./...\n```\n\n**After:**\n```bash\nfo -- go test ./...              # Works same, different rendering\nfo -l \"Build\" -- go build ./...  # Works same, uses theme\nfo --theme ascii -- go test      # New: choose theme\n```\n\n## Acceptance Criteria\n\n- [ ] CLI executes commands and creates CommandResult\n- [ ] Renderer used for output formatting\n- [ ] Theme resolution from flags/env/default\n- [ ] --theme flag to select built-in theme\n- [ ] --theme-file flag for custom themes\n- [ ] Stream mode still works (bypass pattern)\n- [ ] Exit code propagated correctly\n- [ ] --no-color and --ci flags work with themes\n- [ ] Help text updated\n- [ ] Integration test for CLI\n\n## Priority\n\n**P1** - Users need working CLI after renderer changes\n\n## Related\n\n- Depends on: #62 (renderer)\n- Validates: Pattern architecture works for CLI use case","createdAt":"2025-11-23T05:59:11Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdDw","name":"enhancement","description":"New feature or request","color":"a2eeef"}],"number":63,"state":"CLOSED","title":"Implement: Update fo CLI to use pattern-based renderer","updatedAt":"2025-11-23T05:59:11Z","closedAt":"2025-01-23T00:00:00Z"}]
