[{"assignees":[],"body":"## Problem\n\nYou've already done a thoughtful thing in `RenderSummary`: skip internal fo errors when summarizing.\n\nRight now that's encoded as a hardcoded prefix list:\n```go\nstrings.HasPrefix(line.Content, \"Error starting command\")\nstrings.HasPrefix(line.Content, \"Error creating stdout pipe\")\nstrings.HasPrefix(line.Content, \"Error creating stderr pipe\")\nstrings.HasPrefix(line.Content, \"[fo] \")\n```\n\nThis same logic appears in multiple places (`RenderSummary`, `RenderOutputLine`, `renderCapturedOutput`).\n\n## Why it matters\n\n1. This string-prefix approach is brittle; any logging change breaks the distinction\n2. \"Internal vs external\" is semantically important: it should be part of the model, not just a string heuristic\n3. Duplicated logic across multiple functions increases maintenance burden\n\n## Concrete correction\n\n1. **Add a field to `OutputLine.Context`, e.g. `IsInternal bool`**, and have the console/exec path set it when errors come from fo itself (e.g. `executeCaptureMode`, `executeStreamMode`, process start failures)\n\n2. **Change `RenderSummary` and `RenderOutputLine` to use `line.Context.IsInternal`** rather than string prefixes\n\n3. **Optionally add a separate internal error summary category** (\"Fo runtime issue: see above\"), to avoid silently hiding your own problems when they're frequent\n\nThis keeps your design system robust even if you refactor human-readable messages.","createdAt":"2025-11-19T02:11:28Z","labels":[],"number":47,"state":"OPEN","title":"P2: Make internal vs external errors a first-class concept","updatedAt":"2025-11-19T02:11:28Z"},{"assignees":[],"body":"## Problem\n\n`LoadConfig` is doing a reasonably clean layered merge:\n- Start with hardcoded defaults (including compiled themes)\n- Overlay YAML `AppConfig` values selectively (only override non-zero fields)\n- Merge YAML themes on top of the built-ins via `DeepCopyConfig` and `normalizeThemeColors`\n\nYou also have CLI flags with `StreamSet`, `NoColorSet`, etc., to track whether they were explicitly set.\n\n## What's missing\n\n1. A clearly encoded \"source of truth\" precedence: CLI → env → YAML → hard defaults, or something similar\n2. A small set of invariants: e.g. `NoColor` should always imply a monochrome theme (or a specific no-color design config) regardless of `ActiveThemeName`\n\n## Concrete correction\n\n1. **Add a single \"merge step\" function**, e.g.:\n   ```go\n   func (c *AppConfig) ApplyCliFlags(flags CliFlags)\n   ```\n   that enforces precedence and invariants in one place\n\n2. **Document precedence in doc.go or README** (even a short section like \"Configuration Layers & Precedence\")\n\n3. **For design**: when `NoColor` is finally resolved true, either:\n   - Force `ActiveThemeName` to \"no_color_derived_from_ascii\", or\n   - Programmatically derive a no-color variant from the active theme (e.g. strip color codes) and set `IsMonochrome`\n\nThis makes the configuration system predictable, which is part of arete: fewer \"why did it do that?\" moments.","createdAt":"2025-11-19T02:11:21Z","labels":[],"number":46,"state":"OPEN","title":"P2: Config layering: document and harden precedence rules","updatedAt":"2025-11-19T02:11:21Z"},{"assignees":[],"body":"## Problem\n\nThe new `InlineProgress` is well-thought-out:\n- TTY detection via `term.IsTerminal`\n- CI mode heuristic: `isCIMode := task.Config.IsMonochrome && task.Config.Style.NoTimer`, then forcing `isTerminal = false`\n- Cursor hide/show, spinner loop with `context.Context`, and debug logging all look solid\n\n## Concerns\n\n1. CI detection is currently inferred from theme (`IsMonochrome + NoTimer`), while you also have an explicit `CI` boolean in `AppConfig`\n2. Cursor hiding is controlled by `enableSpinner && isTerminal && !IsMonochrome`, but you don't explicitly tie this to `AppConfig.CI`\n\n## Concrete correction\n\n1. **Thread `AppConfig.CI` (and/or `CliFlags.CI`) into the design config and InlineProgress constructor** so CI is explicit:\n   ```go\n   func NewInlineProgress(task *Task, debugMode bool, ci bool) *InlineProgress\n   ```\n\n2. **Keep the theme heuristics as a fallback** (\"if CI flag not provided, infer from monochrome + no-timer\"), but prefer explicit CI\n\n3. **Consider centralizing a tiny Environment struct** (`ci, interactive, supportsColor`) so both console and design code read from the same source of truth\n\nThis avoids accidental \"CI-like\" behavior when someone picks a monochrome theme locally.","createdAt":"2025-11-19T02:11:15Z","labels":[],"number":45,"state":"OPEN","title":"P2: InlineProgress: CI/TTY detection and shared config semantics","updatedAt":"2025-11-19T02:11:15Z"},{"assignees":[],"body":"## Problem\n\nIn `RenderStartLine` you compute:\n```go\nlabelRenderedLength := len(t.Label) + 2\ndesiredHeaderContentVisualWidth := 40\nrepeatCount := desiredHeaderContentVisualWidth - labelRenderedLength\n```\n\nAnd `calculateHeaderWidth` uses `len(label)` and a fixed `maxLabelContribution`.\n\n## Why it matters\n\n- `len()` on UTF-8 strings is bytes, not cells; any non-ASCII label will make the header width math wrong\n- `desiredHeaderContentVisualWidth` is a magic constant (40) unrelated to `calculateHeaderWidth`, leading to inconsistent boxes vs footers\n\n## Concrete correction\n\n1. **Introduce a small helper using rune counting** or, ideally, `golang.org/x/text/width` to approximate display width:\n   ```go\n   func visualWidth(s string) int { return len([]rune(s)) }\n   ```\n\n2. **Replace the local `desiredHeaderContentVisualWidth` logic** with a call to a single `calculateHeaderWidth(label)`:\n   - Have `calculateHeaderWidth` accept `Config` or a theme hint so the header and footer share the same width decision\n   - Use visual width calculation instead of byte length\n\n3. **Stick to one code path** for header width so future tweaks propagate\n\nThis is a good \"small, surgical\" improvement that pays off the design ambition.","createdAt":"2025-11-19T02:11:08Z","labels":[],"number":44,"state":"OPEN","title":"P2: Improve header/label rendering for wide & long labels","updatedAt":"2025-11-19T02:11:08Z"},{"assignees":[],"body":"## Problem\n\nThe `PatternMatcher` is a big improvement with:\n- Precompiled patterns for global output + per-tool patterns\n- Special patterns like `fileLinePattern` and `passFailPattern`\n- Intent detection that checks presets, pattern dictionaries, and verb heuristics\n\n## Gaps / opportunities\n\n1. All compiled patterns currently have `Weight: 1` and there's no scoring — you return on first match\n2. `fileLinePattern` and `passFailPattern` aren't clearly integrated as \"strong signal\" classification, versus the generic Output patterns\n3. `DetectCommandIntent` uses `strings.Contains` for intent patterns (not regex), which is fine but a bit inconsistent with the rest\n\n## Concrete corrections\n\n1. **Introduce a small scoring pass in ClassifyOutputLine**:\n   - Each match adds `cp.Weight` to a category score\n   - Return the category with highest score instead of first match\n\n2. **Strong signal integration**:\n   - \"File + error\" lines (matching `fileLinePattern` and an error pattern) should heavily bias toward `TypeError` with high importance\n   - PASS/FAIL lines should strongly set type (`TypeSuccess`/`TypeError`) and `Importance=5`\n\n3. **In the config, allow weighting in YAML** (default 1) so you can tune patterns without touching code\n\n4. **For intent patterns, either**:\n   - Document clearly that `Patterns.Intent` entries are simple substrings, or\n   - Optionally allow regex with a flag (`intent_regex: true`) if you want parity with output patterns\n\nThis makes your design system explainable: when a line is highlighted, you can point to the pattern and weight that caused it.","createdAt":"2025-11-19T02:11:02Z","labels":[],"number":43,"state":"OPEN","title":"P2: Tighten PatternMatcher semantics and weighting","updatedAt":"2025-11-19T02:11:02Z"},{"assignees":[],"body":"## Problem\n\nYou've defined a nice cognitive-load model:\n- `TaskContext` and `LineContext` with `CognitiveLoad` and `Importance` fields\n- `UpdateTaskContext` that derives complexity + load from output size and error/warning counts\n- `ClassifyOutputLine` sets `LineContext.CognitiveLoad` and `Importance`\n\nAnd render paths do some smart things:\n- Inline italics for high-load error lines in `RenderOutputLine`\n- Summary generation that skips internal fo-errors\n\n## Why it matters\n\nThe model is there, but most formatting is still \"flat\". You're paying the complexity cost of cognitive-load plumbing without fully reaping the UX win. Most rendering decisions don't actually use the cognitive load or importance fields.\n\n## Concrete upgrades\n\n1. **Wire UpdateTaskContext into the lifecycle**: Call it once after all output is captured but before final rendering (e.g. just before `RenderEndLine` / `RenderSummary`). Currently it's only called in `executeCaptureMode`.\n\n2. **In RenderOutputLine, use LineContext.Importance to**:\n   - Dim low-importance detail lines when `Task.Context.CognitiveLoad == LoadHigh`\n   - Optionally elide or collapse low-importance lines into a \"(+N more details...)\" line when the task is noisy\n\n3. **In RenderSummary, reflect complexity**: For very high complexity tasks, add an extra \"See above for detailed log\" note, or show both counts and a brief descriptor (\"5 errors, 17 warnings across 200 lines\").\n\nThis turns the \"research-backed design\" story from prose into behavior.","createdAt":"2025-11-19T02:10:55Z","labels":[],"number":42,"state":"OPEN","title":"P2: Make cognitive-load awareness drive formatting decisions","updatedAt":"2025-11-19T02:10:55Z"},{"assignees":[],"body":"## Problem\n\nCurrently there are two separate ANSI normalization routines:\n\n1. `normalizeANSIEscape` in `internal/design/config.go` (lines 187-218)\n2. A very similar normalization routine inside `internal/config/config.go`'s `normalizeThemeColors` closure (lines 234-249) that re-implements the same \"actual ESC vs \\\\x1b/\\\\033\" logic\n\nBoth functions handle:\n- Actual ESC character detection\n- Octal escape sequence \\\\033 handling  \n- Double-escaped \\\\x1b and \\\\033 literal strings from YAML\n\n## Why it matters\n\nANSI handling is notoriously fiddly; having two near-copies almost guarantees they'll drift apart. Bugs here manifest as \"random color glitches\" that are hard to tie back to config.\n\n## Concrete correction\n\n1. Move `normalizeANSIEscape` into a small, focused package-level API in `design` (e.g. `NormalizeANSIEscape(string) string` or make it exported)\n2. In `internal/config/config.go`, call that function instead of re-implementing it\n3. Add a tiny test table for escape cases (plain \\\\x1b, octal \\\\033, double-escaped \\\\\\\\x1b etc.) so any future theme changes are protected\n\nThis ensures a single source of truth for ANSI escape handling across the codebase.","createdAt":"2025-11-19T02:10:49Z","labels":[],"number":41,"state":"OPEN","title":"P3: DRY up ANSI normalization and make escape handling first-class","updatedAt":"2025-11-19T02:10:49Z"},{"assignees":[],"body":"examples/mage/go.mod uses replace directive pointing to ../... This works for local dev but breaks go install for users trying to run the example without the full repo structure. Add comment explaining this is for local dev, or use go.work for local dev and keep example go.mod pointing to canonical remote version.","createdAt":"2025-11-19T01:35:09Z","labels":[],"number":34,"state":"CLOSED","title":"P4: examples/mage go.mod uses replace directive blocking standalone usage","updatedAt":"2025-11-19T01:45:37Z"},{"assignees":[],"body":"Top-level README describes fo CLI but doesn't mention mageconsole for programmatic usage. mageconsole README mentions themes but doesn't explain it's the engine behind fo CLI. Add Programmatic Usage section to fo README pointing to mageconsole. Add note to mageconsole README that all fo CLI behaviors are available as library.","createdAt":"2025-11-19T01:34:17Z","labels":[],"number":33,"state":"CLOSED","title":"P4: README doesn't cross-link fo CLI and mageconsole library","updatedAt":"2025-11-19T01:45:36Z"},{"assignees":[],"body":"internal/design/render.go uses string literals (\"h1\", \"raw\", \"success\") for message types throughout. This is typo-prone and lacks IDE support. Define MessageType enum with exported constants for type safety and autocomplete.","createdAt":"2025-11-19T01:33:53Z","labels":[],"number":32,"state":"CLOSED","title":"P4: Stringly-typed rendering logic prone to typos","updatedAt":"2025-11-19T01:45:34Z"},{"assignees":[],"body":"magefile.go QA task treats staticcheck, golangci-lint, gosec failures as warnings only. For a project aspiring to quality, QA should fail if these tools report issues. Recommendation: detect exec.ErrNotFound to warn only when tool is missing, otherwise bubble error. Or add QA_STRICT env var for CI.","createdAt":"2025-11-19T01:33:45Z","labels":[],"number":31,"state":"CLOSED","title":"P3: QA task allows linter failures without blocking","updatedAt":"2025-11-19T01:44:02Z"},{"assignees":[],"body":"cmd/main.go has main() handle logic and call os.Exit directly. This terminates the test runner, making integration tests impossible. Refactor: move logic to run(args []string) int, main becomes os.Exit(run(os.Args)). Allows TestMain to safely invoke application logic.","createdAt":"2025-11-19T01:33:35Z","labels":[],"number":30,"state":"CLOSED","title":"P3: main() calls os.Exit making integration tests impossible","updatedAt":"2025-11-19T01:43:10Z"},{"assignees":[],"body":"On Unix systems, getExitCode properly extracts the actual exit code from syscall.WaitStatus. On non-Unix systems (Windows), process_other.go always returns (0, false), causing the fallback to assume exit code 1 for any non-zero exit.\n\nThis means exit codes 2, 42, 137 etc. are all surfaced as 1 on Windows, even though there may be ways to get more detail on modern Windows.\n\nImpact: Users on Windows who care about specific exit codes for CI or scripting get incorrect values. The ErrNonZeroExit design would ideally preserve the actual exit code cross-platform.\n\nConsider investigating syscall.WaitStatus or the windows package for Windows to recover proper exit codes. At minimum, document that ExitCode is currently limited on non-Unix platforms.","createdAt":"2025-11-19T01:32:11Z","labels":[],"number":29,"state":"CLOSED","title":"P3: Windows exit code handling returns 1 for all non-zero exits","updatedAt":"2025-11-19T01:41:43Z"},{"assignees":[],"body":"Capture mode waits for the entire command to finish, then classifies all output at once. This means:\n- No intelligent classification visible until command completes\n- Memory requirements scale with total output size\n- Classification cost is paid all at once at the end\n\nFor long-running commands with steady output, consider streaming classification: read stdout/stderr line-by-line, classify immediately, append to task.OutputLines. This would pair well with fixing the MaxBufferSize enforcement.\n\nNot strictly a bug but the current approach contradicts the tool philosophy of intelligent output formatting. When classification happens matters for UX.","createdAt":"2025-11-19T01:30:01Z","labels":[],"number":28,"state":"CLOSED","title":"P2: Capture mode buffers everything before classification","updatedAt":"2025-11-19T01:37:59Z"},{"assignees":[],"body":"Classification runs all regex patterns against every output line. For 10k lines and 20 patterns, this is 200k regex ops.\n\nAdd fast-path string prefix checks (panic:, Error:, warning:) before falling back to regex. Most patterns have static prefixes that can be checked with strings.Contains which is orders of magnitude faster.\n\nImpact: Measurable overhead on verbose builds. The wrapper slows down the wrapped command.","createdAt":"2025-11-19T01:29:49Z","labels":[],"number":27,"state":"CLOSED","title":"P2: Regex classification O(N*M) performance bottleneck","updatedAt":"2025-11-19T01:37:58Z"},{"assignees":[],"body":"## Problem\n\nThe inline progress spinner hides the terminal cursor using ANSI escape codes but doesn't guarantee restoration if the program crashes or receives a SIGKILL. This leaves users with an invisible cursor, requiring a manual terminal reset.\n\n## Current Behavior\n\nIn internal/design/progress.go, the cursor is hidden when the spinner starts and shown when it completes:\n```go\nfunc (p *InlineProgress) Start(ctx context.Context, useSpinner bool) {\n    if useSpinner && p.interactive {\n        p.out.Write([]byte(\"\\033[?25l\"))  // Hide cursor\n    }\n}\n\nfunc (p *InlineProgress) Complete(status string, duration time.Duration) {\n    if p.interactive && p.useSpinner {\n        p.out.Write([]byte(\"\\033[?25h\"))  // Show cursor\n    }\n}\n```\n\nThe problem is that if the program terminates before Complete() is called, the cursor stays hidden.\n\n**Scenarios that break cursor state:**\n- kill -9 (SIGKILL - uncatchable)\n- Panic in classification or rendering code\n- Program crashes due to OOM or other fatal error\n- User sends Ctrl+C but signal handler fails\n\n## Expected Behavior\n\nCursor restoration should be handled at the highest possible level with defensive coverage. In mageconsole/console.go runContext() or Run():\n```go\nfunc (c *Console) Run(label, command string, args ...string) (*TaskResult, error) {\n    // Set up cursor restoration at the outermost level\n    if c.cfg.InlineProgress && isInteractiveTerminal(c.cfg.Out) {\n        c.cfg.Out.Write([]byte(\"\\033[?25l\"))\n        \n        // Ensure cursor is restored on ANY exit path\n        defer func() {\n            c.cfg.Out.Write([]byte(\"\\033[?25h\"))\n            c.cfg.Out.Write([]byte(\"\\n\"))\n        }()\n    }\n    // ... existing execution ...\n}\n```\n\nAdditionally, the signal handler should explicitly restore cursor before forwarding signals.\n\n## Impact\n\n**Severity:** P1 - User experience bug\n- Users left with invisible cursor after fo crashes\n- Requires manual reset or tput cnorm to fix\n- Common in CI environments where jobs are killed forcefully\n- Creates perception that fo broke my terminal\n\nNote: SIGKILL cannot be caught, but we can protect against panics, most signals, and graceful shutdowns with proper defer placement.","createdAt":"2025-11-19T01:24:16Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdBQ","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":26,"state":"CLOSED","title":"P1: Terminal cursor not restored after crash or SIGKILL","updatedAt":"2025-11-19T01:37:56Z"},{"assignees":[],"body":"## Problem\n\nThe documented error semantics for `Run()` and `RunSimple()` don't match the implementation, making `ErrNonZeroExit` effectively dead code. This violates the principle of least surprise for library users.\n\n## Current State\n\n**Documentation says:**\n- Run returns (result, nil) on exit code 0, and (result, error) on non-zero\n- ErrNonZeroExit is the canonical error to detect non-zero exits\n- RunSimple returns ErrNonZeroExit for non-zero exit codes\n\n**Implementation does:**\n```go\n// In runContext() - returns raw exec.ExitError for non-zero exit\nif exitCode != 0 {\n    return result, cmdRunError  // This is exec.ExitError, NOT ErrNonZeroExit\n}\n\n// In RunSimple()\nfunc (c *Console) RunSimple(command string, args ...string) error {\n    res, err := c.Run(\"\", command, args...)\n    if err != nil {\n        return err  // Returns exec.ExitError, bypassing code below\n    }\n    // NEVER REACHED because Run already returned an error\n    if res != nil && res.ExitCode != 0 {\n        return fmt.Errorf(\"%w: %d\", ErrNonZeroExit, res.ExitCode)\n    }\n    return nil\n}\n```\n\n## Impact\n\n**Severity:** P1 - API correctness bug\n- Users who check `errors.Is(err, mageconsole.ErrNonZeroExit)` will never match\n- Documentation promises behavior that doesn't exist\n- ErrNonZeroExit is exported but functionally useless\n- Makes error handling unpredictable for library consumers\n\n## Recommended Fix\n\nKeep Run raw, fix RunSimple (minimal breaking change):\n```go\nfunc (c *Console) RunSimple(command string, args ...string) error {\n    res, err := c.Run(\"\", command, args...)\n    if err == nil {\n        return nil\n    }\n\n    // Map exec.ExitError to our wrapper\n    var exitErr *exec.ExitError\n    if errors.As(err, &exitErr) {\n        code := getExitCode(err, c.cfg.Debug)\n        return fmt.Errorf(\"%w: %d\", ErrNonZeroExit, code)\n    }\n    return err  // Infrastructure error, pass through\n}\n```\n\nUpdate Run() godoc to clarify it returns raw exec.ExitError.\n\n## Testing Needed\n\n```go\nfunc TestRunSimpleErrorSemantics(t *testing.T) {\n    console := NewConsole(ConsoleConfig{})\n    \n    // Non-zero exit should return ErrNonZeroExit\n    err := console.RunSimple(\"false\")\n    if !errors.Is(err, ErrNonZeroExit) {\n        t.Errorf(\"Expected ErrNonZeroExit, got %v\", err)\n    }\n    \n    // Command not found should NOT return ErrNonZeroExit\n    err = console.RunSimple(\"command-does-not-exist-xyz\")\n    if errors.Is(err, ErrNonZeroExit) {\n        t.Error(\"Command not found should not return ErrNonZeroExit\")\n    }\n}\n```","createdAt":"2025-11-19T01:23:43Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdBQ","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":25,"state":"CLOSED","title":"P1: Run() vs RunSimple() error semantics don't match documentation","updatedAt":"2025-11-19T01:37:55Z"},{"assignees":[],"body":"## Problem\n\nThe signal handler goroutine in `Console.Run` contains a logical deadlock and will leak on every command execution. The goroutine waits on `cmdDone` in a select statement, but `cmdDone` is only closed by the goroutine's own defer after the select returns—creating unreachable dead code.\n\n## Current Behavior\n\nLines 146-201 in mageconsole/console.go:\n```go\ncmdDone := make(chan struct{})\ngo func() {\n    defer close(cmdDone)  // This runs AFTER the select below returns\n    select {\n    case sig := <-sigChan:\n        // ... handle signal ...\n    case <-ctx.Done():\n        // ... context cancelled ...\n    case <-cmdDone:  // DEAD CODE: this case can never execute\n        // The channel is only closed by the defer above,\n        // which runs after this select statement completes\n        return\n    }\n}()\n```\n\n**What happens:** For a successful command execution (no signal, no context cancellation), the goroutine blocks forever. The select never completes because no case matches. Memory leak of goroutine + channel per Run() call.\n\n## Expected Behavior - Option A (cleaner)\n\nUse signal.NotifyContext:\n```go\nfunc (c *Console) Run(label, command string, args ...string) (*TaskResult, error) {\n    ctx, stop := signal.NotifyContext(context.Background(), getInterruptSignals()...)\n    defer stop()\n    return c.runContext(ctx, label, command, args)\n}\n```\n\n## Expected Behavior - Option B (more control)\n\n```go\ncmdDone := make(chan struct{})\n\n// Goroutine 1: Wait for command completion\ngo func() {\n    _ = cmd.Wait()\n    close(cmdDone)\n}()\n\n// Goroutine 2: Handle signals\ngo func() {\n    defer signal.Stop(sigChan)\n    select {\n    case sig := <-sigChan:\n        killProcessGroup(cmd, sig)\n        select {\n        case <-cmdDone:\n            return\n        case <-time.After(2 * time.Second):\n            killProcessGroupWithSIGKILL(cmd)\n        }\n    case <-cmdDone:\n        return\n    }\n}()\n```\n\n## Impact\n\n**Severity:** P0 - Critical correctness bug\n- Every Run() call leaks a goroutine\n- Long-running processes will accumulate goroutines\n- Eventually hits goroutine scheduler limits or memory pressure\n- Signal handling still works but leaves garbage behind\n\n## Reproduction\n\n```go\nconsole := mageconsole.NewConsole(mageconsole.ConsoleConfig{})\nfor i := 0; i < 1000; i++ {\n    _, _ = console.Run(\"test\", \"echo\", \"hello\")\n}\n// Check runtime.NumGoroutine() - will show 1000+ leaked goroutines\n```","createdAt":"2025-11-19T01:23:22Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdBQ","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":24,"state":"CLOSED","title":"P0: Signal handler goroutine leak on every Run() call","updatedAt":"2025-11-19T01:37:54Z"},{"assignees":[],"body":"## Problem\n\nIn capture mode, `mageconsole/console.go` reads the entire stdout and stderr streams into memory before applying `MaxBufferSize` limits. If a wrapped command produces gigabytes of output or enters an infinite logging loop, fo will crash with an Out Of Memory error before it can truncate the output.\n\n## Current Behavior\n\nLines 296-307 in console.go show the bug:\n```go\ngo func() {\n    defer wgRead.Done()\n    // BUG: This copies ALL output into memory first\n    _, errStdoutCopy = io.Copy(&stdoutBuffer, stdoutPipe)\n    // ... then we apply the limit AFTER everything is in memory\n}()\n\n// Lines 324-328\nlimitedStdout := io.LimitReader(&stdoutBuffer, c.cfg.MaxBufferSize)\n_, _ = outputBuffer.ReadFrom(limitedStdout)\n```\n\nThe sequence is: (1) io.Copy reads the entire pipe into stdoutBuffer (unbounded), (2) Wait for command to complete, (3) Then create a LimitReader from the already-full buffer.\n\n## Expected Behavior\n\nApply MaxBufferSize limit during the copy operation, not after:\n```go\ngo func() {\n    defer wgRead.Done()\n    // Apply limit immediately to prevent OOM during copy\n    limitedReader := io.LimitReader(stdoutPipe, c.cfg.MaxBufferSize)\n    _, errStdoutCopy = io.Copy(&stdoutBuffer, limitedReader)\n}()\n```\n\n## Impact\n\n**Severity:** P0 - Production blocker\n- Wrapping verbose CI builds (npm install, go test -v) can exhaust system memory\n- Malicious or buggy commands can DoS the host system\n- No graceful degradation when output exceeds available RAM\n\n## Additional Considerations\n\nSince we have separate stdout and stderr streams, consider:\n1. Should MaxBufferSize be a shared budget across both streams?\n2. Or should each stream get its own limit (current behavior, effectively 2x)?\n3. Add a truncated marker when output exceeds the limit","createdAt":"2025-11-19T01:23:02Z","labels":[{"id":"LA_kwDOOpIJEM8AAAACAOfdBQ","name":"bug","description":"Something isn't working","color":"d73a4a"}],"number":23,"state":"CLOSED","title":"P0: Unbounded memory usage in capture mode causes OOM risk","updatedAt":"2025-11-19T01:37:52Z"},{"assignees":[],"body":"## Problem\nREADME.md only covers CLI usage. Library consumers need documentation.\n\n## Needed Documentation\n\n### 1. mageconsole/README.md\n- Quick start example\n- API reference\n- Configuration options\n- Common patterns\n\n### 2. Enhanced GoDoc\nAdd detailed comments to all exported functions:\n- Console.Run\n- Console.RunSimple  \n- NewConsole\n- ConsoleConfig fields\n\n### 3. Examples directory\n- examples/basic-usage/\n- examples/custom-config/\n- examples/error-handling/\n- examples/streaming-output/\n\n### 4. Migration Guide\nFor users of the fo CLI transitioning to library usage.\n\n## Reference\nSee CTM doc goal: make this a reusable library for other Go projects.\n","createdAt":"2025-11-18T20:42:10Z","labels":[],"number":19,"state":"CLOSED","title":"Tier 5: Add comprehensive documentation for library consumers","updatedAt":"2025-11-19T00:34:27Z"},{"assignees":[],"body":"## Problem\nNo integration tests verify the mageconsole library works correctly in actual Mage tasks.\n\n## Needed\nCreate examples/mage/magefile_test.go:\n\n```go\nfunc TestMagefileIntegration(t *testing.T) {\n    cmd := exec.Command(\"mage\", \"build:all\")\n    output, err := cmd.CombinedOutput()\n    require.NoError(t, err)\n    assert.Contains(t, string(output), \"Complete\")\n}\n\nfunc TestMagefileIntegration_Failure(t *testing.T) {\n    // Test that failures are properly reported\n}\n\nfunc TestMagefileIntegration_MultipleConsoleUses(t *testing.T) {\n    // Verify Console can be reused across tasks\n}\n```\n\n## Why Important\nThis validates the core use case for the library refactor described in the CTM doc.\n","createdAt":"2025-11-18T20:41:50Z","labels":[],"number":18,"state":"CLOSED","title":"Tier 5: Add integration tests for Mage usage pattern","updatedAt":"2025-11-19T00:33:39Z"},{"assignees":[],"body":"## Problem\nMultiple files have formatting violations:\n- internal/design/config.go\n- internal/design/recognition_test.go\n- internal/design/render_test.go\n- internal/design/system_test.go\n- magefile.go\n\n## Fix\nRun: `gofmt -w .`\n\n## Prevention\nAdd to CI pipeline:\n```yaml\n- name: Check formatting\n  run: |\n    if [ -n \"$(gofmt -l .)\" ]; then\n      echo \"Files need formatting:\"\n      gofmt -l .\n      exit 1\n    fi\n```\n","createdAt":"2025-11-18T20:41:41Z","labels":[],"number":17,"state":"CLOSED","title":"Tier 5: Run gofmt on all source files","updatedAt":"2025-11-19T00:20:15Z"},{"assignees":[],"body":"## Problem\nThe mageconsole package (primary API surface) has 0% test coverage.\n\n## Impact\n- Core library functionality is untested\n- No validation of Run/RunSimple behavior\n- Signal handling untested\n- Capture vs Stream modes untested\n\n## Critical Tests Needed\n- TestConsole_Run_Success\n- TestConsole_Run_Failure  \n- TestConsole_Run_SignalHandling\n- TestConsole_Run_CaptureVsStream\n- TestConsole_Run_ConfigOverrides\n- TestConsole_Run_MaxBufferHandling\n- TestConsole_Run_MaxLineLengthHandling\n- TestNewConsole_ConfigNormalization\n\n## Note\nThis is essential for the mageconsole library to be production-ready.\n","createdAt":"2025-11-18T20:41:34Z","labels":[],"number":16,"state":"CLOSED","title":"Tier 5: Zero test coverage for mageconsole package","updatedAt":"2025-11-19T00:25:18Z"},{"assignees":[],"body":"## Problem\nThe main entry point has 0% test coverage, making it impossible to verify CLI behavior.\n\n## Impact  \n- No verification that flag parsing works  \n- No tests for command execution flow  \n- No validation of exit code handling  \n- Regression risk for any changes  \n\n## Tests Needed  \n- Version flag handling  \n- Print subcommand  \n- Invalid arguments  \n- Config file loading  \n- Exit code propagation  \n","createdAt":"2025-11-18T20:41:27Z","labels":[],"number":15,"state":"CLOSED","title":"Tier 5: Zero test coverage for cmd/main.go entry point","updatedAt":"2025-11-19T00:26:01Z"},{"assignees":[],"body":"**Tier:** 4 - Nice-to-Have UX / Progress Refinement\n\n**Problem:**\nInlineProgress uses \\r\\033[K and writes straight to stdout; it works, but:\n- Doesn't control cursor visibility.\n- Might flicker with multi-line or when the terminal is resized.\n\n**Action (optional):**\nOnce you've injected Out io.Writer, you can:\n- Optionally hide/show cursor around spinners: \\033[?25l / \\033[?25h.\n- Consider a \"simple progress\" mode that only ever prints one line per update when embedded in logs.\n\n**Why:**\nNot critical, but it takes the UX from \"nice\" to \"delightful\".","createdAt":"2025-11-18T19:54:02Z","labels":[],"number":14,"state":"CLOSED","title":"Tier 4: Progress rendering polish","updatedAt":"2025-11-18T23:23:21Z"},{"assignees":[],"body":"**Tier:** 3 - Quality of Life & Maintainability\n\n**Problem:**\nManual deep copy is easy to forget when you add fields.\n\n**Action (pick one):**\n1. Keep manual copying but:\n   - Add a test that round-trips all fields, so missing fields break tests.\n   - Or enforce via a linter comment.\n2. Or use a generic approach (JSON marshal/unmarshal) if Config is simple enough and you're okay with the overhead in non-hot paths.\n\n**Why:**\nConfigs tend to grow; you don't want \"copy bug\" regressions.","createdAt":"2025-11-18T19:53:59Z","labels":[],"number":13,"state":"CLOSED","title":"Tier 3: Safer DeepCopyConfig","updatedAt":"2025-11-18T23:22:25Z"},{"assignees":[],"body":"**Tier:** 3 - Quality of Life & Maintainability\n\n**Problem:**\nManual concatenation of \"\\x1b[31m\" etc. is verbose and brittle.\n\n**Action:**\nDefine a tiny Color type:\n\n```go\ntype Color struct {\n    code string\n}\n\nfunc (c Color) Sprint(s string) string {\n    return c.code + s + Reset\n}\n```\n\nStore Color objects in your theme/config and use them consistently instead of scattering raw escape sequences.\n\n**Why:**\nReduces mistakes, makes themes easier to reason about, and keeps escape logic in one place.","createdAt":"2025-11-18T19:53:57Z","labels":[],"number":12,"state":"CLOSED","title":"Tier 3: Improve ANSI handling","updatedAt":"2025-11-19T00:21:23Z"},{"assignees":[],"body":"**Tier:** 3 - Quality of Life & Maintainability\n\n**Problem:**\nRenderEndLine / RenderOutputLine have high cyclomatic complexity and lots of boolean flags.\n\n**Action:**\nExtract small helpers:\n- renderStatusBlock(t *Task) string\n- renderDuration(t *Task) string\n- renderSummaryBanner(t *Task) string\n- renderOutputLineStyled(line OutputLine, cfg *Config) string\n\nKeep each one focused and testable.\n\n**Why:**\nThis matches your design intent (ElementStyleDef + components) and makes it much easier to tweak visuals without introducing subtle logic bugs.","createdAt":"2025-11-18T19:53:55Z","labels":[],"number":11,"state":"CLOSED","title":"Tier 3: Break up complex render functions","updatedAt":"2025-11-18T23:21:00Z"},{"assignees":[],"body":"**Tier:** 3 - Quality of Life & Maintainability\n\n**Problem:**\nYou use errCommandExited + sometimes pattern-match error strings for \"executable not found\". That's workable but not clear.\n\n**Action:**\n1. Decide on a contract:\n   - Run: error != nil only for infra problems (start failure, IO error, context cancelled), or also for non-zero exit?\n   - Pick one, document it.\n2. Represent \"command ran but exited non-zero\" either via:\n   - TaskResult.ExitCode + a sentinel error like ErrNonZeroExit, or\n   - Just ExitCode and no error; caller decides.\n3. Replace brittle string matching with errors.Is / errors.As:\n   ```go\n   if errors.Is(err, exec.ErrNotFound) {\n       // ...\n   }\n   ```\n4. If you must handle old Go versions, isolate the string fallback in one helper, not inline.\n\n**Why:**\nYou'll be calling this from Mage and possibly other tools; predictable semantics avoid a lot of awkward branching downstream.","createdAt":"2025-11-18T19:53:51Z","labels":[],"number":10,"state":"CLOSED","title":"Tier 3: Document and clean up error semantics","updatedAt":"2025-11-18T23:19:44Z"},{"assignees":[],"body":"**Tier:** 2 - API & Testability Hardening\n\n**Problem:**\nTaskResult currently exposes []design.OutputLine, tying your public API to the internal engine.\n\n**Action:**\n1. Define a small exported type in mageconsole:\n\n```go\ntype Line struct {\n    Raw   string\n    Type  string\n    Time  time.Time\n}\n```\n\n2. Have TaskResult use []Line.\n3. In Run, map from design.OutputLine to mageconsole.Line.\n\n**Why:**\nGives you freedom to refactor design without breaking Orca/mageclients.","createdAt":"2025-11-18T19:53:47Z","labels":[],"number":9,"state":"CLOSED","title":"Tier 2: Don't leak design types through mageconsole","updatedAt":"2025-11-18T23:18:25Z"},{"assignees":[],"body":"**Tier:** 2 - API & Testability Hardening\n\n**Problem:**\nPackage-level mutable state in main (cliFlagsGlobal) makes behavior harder to reason about and test.\n\n**Action:**\n1. Define a CLIConfig struct with all the flags.\n2. Make parseGlobalFlags(os.Args) return CLIConfig, []string (cmd+args), error.\n3. Pass that into a run(config CLIConfig, cmd []string) function instead of relying on globals.\n\n**Why:**\nThis is cheap to fix now and makes the fo CLI more maintainable / testable.","createdAt":"2025-11-18T19:53:44Z","labels":[],"number":8,"state":"CLOSED","title":"Tier 2: Eliminate global CLI state (cliFlagsGlobal)","updatedAt":"2025-11-18T23:17:20Z"},{"assignees":[],"body":"**Tier:** 2 - API & Testability Hardening\n\n**Problem:**\nRendering/progress writes straight to os.Stdout, which:\n- Makes unit testing awkward (redirecting global stdout).\n- Makes it hard to embed in other systems that want to capture output.\n\n**Action:**\nAdd Out io.Writer (and optionally Err io.Writer) to:\n- Console\n- Task\n- InlineProgress\n\nDefault them to os.Stdout in mageconsole.NewConsole, but let callers override.\n\nReplace fmt.Println / os.Stdout.WriteString with fmt.Fprintln(p.Out, ...), etc.\n\n**Why:**\nThis unlocks real tests (use bytes.Buffer), and gives you flexibility if you ever want to pipe this into a log aggregator or UI.","createdAt":"2025-11-18T19:53:42Z","labels":[],"number":7,"state":"CLOSED","title":"Tier 2: Inject io.Writer instead of hardcoding os.Stdout / os.Stderr","updatedAt":"2025-11-18T23:16:02Z"},{"assignees":[],"body":"**Tier:** 1 - Make It Correct and Cross-Platform\n\n**Problem:**\nIn stream mode you start goroutines to scan stdout/stderr and then call cmd.Wait(). If you return as soon as Wait() ends, the scanner goroutines may not have finished consuming the pipes, so the last lines might not make it into your Task.\n\n**Action:**\nIntroduce a sync.WaitGroup for stdout/stderr scanners:\n\n```go\nvar wg sync.WaitGroup\nwg.Add(2)\n\n// stdout scanner goroutine\ngo func() {\n    defer wg.Done()\n    // scan lines...\n}()\n\n// stderr scanner goroutine\ngo func() {\n    defer wg.Done()\n    // scan lines...\n}()\n\nerr := cmd.Wait()\nwg.Wait()\n```\n\nOnly then compute exitCode and return.\n\n**Why:**\nYou don't want \"flake-y\" loss of last lines in error logs. This is subtle and exactly the kind of thing that will drive you nuts under load.","createdAt":"2025-11-18T19:53:38Z","labels":[],"number":6,"state":"CLOSED","title":"Tier 1: Fix potential race in stream mode (scanner goroutine vs cmd.Wait)","updatedAt":"2025-11-18T23:13:25Z"},{"assignees":[],"body":"**Tier:** 1 - Make It Correct and Cross-Platform\n\n**Problem:**\nThe syscall.Setpgid + Kill(-pgid, …) logic is Unix-only. On Windows this either won't compile or will behave unpredictably.\n\n**Action:**\nMove process-group-specific bits into console_unix.go:\n\n```go\n//go:build unix\n\nfunc setProcessGroup(cmd *exec.Cmd) {\n    cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}\n}\n\nfunc killProcessGroup(cmd *exec.Cmd, sig os.Signal) error {\n    pgid, err := syscall.Getpgid(cmd.Process.Pid)\n    if err != nil {\n        return err\n    }\n    return syscall.Kill(-pgid, sig.(syscall.Signal))\n}\n```\n\nAnd a simpler version for console_other.go:\n\n```go\n//go:build !unix\n\nfunc setProcessGroup(cmd *exec.Cmd) {\n    // no-op or platform-specific\n}\n\nfunc killProcessGroup(cmd *exec.Cmd, sig os.Signal) error {\n    return cmd.Process.Signal(sig)\n}\n```\n\nCall these helpers from your existing signal-handling code.\n\n**Why:**\nEven if you only really care about Unix, it's nice to have clean build behavior and not be surprised later.","createdAt":"2025-11-18T19:53:34Z","labels":[],"number":5,"state":"CLOSED","title":"Tier 1: Split process-group / signal logic with build tags","updatedAt":"2025-11-18T23:16:01Z"},{"assignees":[],"body":"**Tier:** 0 - Absolute Must-Fix Before Heavy Use\n\n**Problem:**\nYou're doing byte slicing around sequences like \\x00 and 33[. That means you're compensating for some upstream encoding / YAML behavior in a very fragile way.\n\n**Action:**\n1. Identify where those strings come from:\n   - .fo.yaml (or other config) → yaml.Unmarshal → your config struct.\n2. Make sure your color / escape sequences are just normal YAML strings:\n   - e.g. \"\\x1b[32m\" or \"\\^[[32m\" depending on preference.\n3. Delete the byte-offset hack and:\n   - Either trust yaml's normal string handling, or\n   - Store symbolic names (\"green\", \"warning\") and map those to ANSI codes in Go (which you're already mostly doing).\n\n**Why now:**\nThis is the kind of thing that works for you today and then explodes unexpectedly when a config file changes, a tool upgrades, or someone edits the YAML \"helpfully\".","createdAt":"2025-11-18T19:53:30Z","labels":[],"number":4,"state":"CLOSED","title":"Tier 0: Remove the \"magic byte\" hack in ensureEscapePrefix","updatedAt":"2025-11-18T23:16:00Z"},{"assignees":[],"body":"**Tier:** 0 - Absolute Must-Fix Before Heavy Use\n\n**Problem:**\nClassifyOutputLine is called for every stdout/stderr line, and if you're compiling regexes inside that loop, you're turning line classification into a CPU furnace.\n\n**Action:**\nChange your patterns repo type to something like:\n\n```go\ntype CompiledPattern struct {\n    Re      *regexp.Regexp\n    Type    LineType\n    Weight  int\n    // whatever metadata you already have\n}\n\ntype PatternRepo struct {\n    OutputPatterns []CompiledPattern\n    // ...\n}\n```\n\n- On config init (or NewPatternMatcher), compile all regexes once.\n- In ClassifyOutputLine, only call re.MatchString(line) on those precompiled objects.\n\n**Why now:**\nThis is the most direct perf/stability win. If you ever wrap something noisy (go test -v, gotestsum, linters), this will be the difference between \"feels snappy\" and \"why is this so laggy?\".","createdAt":"2025-11-18T19:53:26Z","labels":[],"number":3,"state":"CLOSED","title":"Tier 0: Precompile all regexes in recognition.go (hot-path perf)","updatedAt":"2025-11-18T21:14:06Z"}]
